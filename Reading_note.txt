2015. 01. 30 (금)
< 전문가를 위한 C++ >
 110p ~ 119p

2.5 코드의 재사용
프로들은 절대 바닥에서부터 프로젝트를 시작하지 않는다. 표준 템플릿 라이브러리, 오픈 소스, 코드 자산, 나의 코드 등을 종합하여 재사용

재사용 가능한 코드
과거 코드, 동료 코드, 협력 업체 코드

독립 함수 또는 클래스
라이브러리 - 특정 작업을 위한 코드의 집합
프레임워크 - 연계될 주변 코드들의 집합

API(어플리케이션 프로그래밍 인터페이스) - 특정 목적의 라이브러리나 코드를 이용하기 위한 창구

코드 재사용의 장점 - 시간이 얼마나 걸릴지 파악가능, 본체 디자인이 심플해짐, 디버깅이 필요없다.다양한 문제 상황에 대응할 수 있다.
잘못된 입력에도 강하다. 전문가의 코드를 쓰면 좋다. 안전하니까 라이브러리는 개선된다.

코드 재사용의 단점 - 정확히 이해하고 상용하기 어렵다. 현재 문제에 딱 맞는 동작을 하게 하기가 어렵다. 필요한 성능이 안나올 수 있다.
유지보수 문제를 일으킬 수 있다. 라이브러리에 버그가 발견되면 내부에 개인적으로 접근 불가. 라이센스 문제가 발생할 수 있다.
크로스 플렛폼 호환성 문제가 있을 수 있다. 신뢰가 필요하다(내가 안짰으니까) 라이브러리 업그래이드시 문제 발생각능하다.

코드 재사용 전략
라이브러리 또는 프레임워크 사용시 염두에 둬야할 것

 멀티스레트 프로그램에서 사용해도 안전한가?
 사용하기 전 초기화 루틴은 어떤 게 있나~?
 종료시 수행해야하는 게 있나~?
 의존하는 다른 라이브러리 또는 프레임 워크가 있나~?

라이브러리 함수를 호출시 고려할 것
 
 메모리 해제는 누가하나? - 스마트 포인터 *21장
 체크되는 에러 조건, 기본적으로 가정되는 조건들은 무엇인가? 에러는 어떻게 알려주나? (종료해버리는 라이브러리는 피해라!)
 리턴 값이 무엇인가 익셉션은 무엇이있나

프레임 워크 사용시 염두에 둘 것
 
 클래스 상속시 어떤 생성자를 호출하고 어떤 가상 함수를 오버라이딩해서 구현해야하나
 직접 해제할 메모리가 있나?

성능에 대한 이해 
BIG-O 표기법 
O(f(n)) = s + C*f(n)+t
s는 작업 준비시간
C는 비례상수
t는 작업 정리 시간

빅오로 좋은데 나쁠 수도 있음 -> 디스크 접근 반영 x인 이야기
빅오가 같으면 비교가 힘듬
n값에 따라 성능이 왜곡일 수 있음 -> 충분히 클때 성립

*90/10 법칙 -> 90%의 실행 시간이 10%의 코드에서 발생한다 
문서는 믿지마라

라이센스와 기술지원에 대한이해
(ㅎㅎ;;; 법률 상담 하세요)

도움 요청 방법 알기
책을 찾아볼 수 있다! -> 웹사이트는 바로 믿지마라!

프로토 타이핑
프로토 타이핑을 구현해보는게 가장 좋다. 직접써보면 아는 거 ㅇㅋ?
이게 낭비라고 생각하지 말자! 친숙해지는 것이 목적이다.


< 문제로 풀어보는 알고리즘 >
 - 집에 가서 읽을게요 